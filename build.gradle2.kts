import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask
import org.jetbrains.dokka.DokkaConfiguration.Visibility
import org.jetbrains.dokka.gradle.DokkaTask

val cssVersion: String by project
val kotlinVersion: String by project
val logbackVersion: String by project
val loggingVersion: String by project
val ktorVersion: String by project
val hikariVersion: String by project
val pgjdbcVersion: String by project
val postgresVersion: String by project
val exposedVersion: String by project
val micrometerVersion: String by project

val mainClassName = "com.vapi4k.ApplicationKt"

plugins {
  val configVersion: String by System.getProperties()
  val kotlinVersion: String by System.getProperties()
  val ktorVersion: String by System.getProperties()
  val versionsVersion: String by System.getProperties()
  val ktlintVersion: String by System.getProperties()
  kotlin("jvm") version kotlinVersion
  id("org.jetbrains.kotlin.plugin.serialization") version kotlinVersion
  id("io.ktor.plugin") version ktorVersion
  id("com.github.ben-manes.versions") version versionsVersion
  id("com.github.gmazzo.buildconfig") version configVersion
  id("org.jmailen.kotlinter") version ktlintVersion
  id("org.jetbrains.dokka") version "1.9.20"
  id("maven-publish")


  //id("io.gitlab.arturbosch.detekt") version "1.23.6"
}

val vstr = "1.0.1"
val releaseDate = "06/11/2024"

group = "com.vapi4k"
version = vstr

buildConfig {
  useKotlinOutput()
  packageName(project.group.toString())
  documentation.set("Generated by BuildConfig plugin")
  buildConfigField("String", "APP_NAME", "\"${project.name}\"")
  buildConfigField("String", "VERSION", provider { "\"${project.version}\"" })
  buildConfigField("String", "RELEASE_DATE", "\"$releaseDate\"")
  buildConfigField("long", "BUILD_TIME", "${System.currentTimeMillis()}L")
}

//application {
//  mainClass.set("com.vapi4k.ApplicationKt")
//
//  val isDevelopment: Boolean = project.ext.has("development")
//  applicationDefaultJvmArgs = listOf("-Dio.ktor.development=$isDevelopment")
//}

repositories {
  google()
  mavenCentral()
  mavenLocal()
  maven(url = "https://jitpack.io")
}

dependencies {
  implementation("org.jetbrains.kotlin:kotlin-reflect:$kotlinVersion")

  implementation("io.ktor:ktor-client-core-jvm:$ktorVersion")
  implementation("io.ktor:ktor-client-cio:$ktorVersion")
  implementation("io.ktor:ktor-client-encoding:$ktorVersion")
  implementation("io.ktor:ktor-client-content-negotiation-jvm:$ktorVersion")

  implementation("io.ktor:ktor-server-core-jvm:$ktorVersion")
  implementation("io.ktor:ktor-server-cio:$ktorVersion")
  implementation("io.ktor:ktor-server-compression-jvm:$ktorVersion")
  implementation("io.ktor:ktor-server-content-negotiation-jvm:$ktorVersion")
  implementation("io.ktor:ktor-server-call-logging-jvm:$ktorVersion")
  implementation("io.ktor:ktor-server-html-builder-jvm:$ktorVersion")
  implementation("io.ktor:ktor-server-metrics-micrometer:$ktorVersion")

  implementation("io.ktor:ktor-serialization-kotlinx-json-jvm:$ktorVersion")

  implementation("io.micrometer:micrometer-registry-prometheus:$micrometerVersion")

  implementation("com.zaxxer:HikariCP:$hikariVersion")
  implementation("com.impossibl.pgjdbc-ng:pgjdbc-ng-all:$pgjdbcVersion")
  implementation("org.postgresql:postgresql:$postgresVersion")
  implementation("org.jetbrains.exposed:exposed-core:$exposedVersion")
  implementation("org.jetbrains.exposed:exposed-jdbc:$exposedVersion")
  implementation("org.jetbrains.exposed:exposed-json:$exposedVersion")
  implementation("org.jetbrains.exposed:exposed-kotlin-datetime:$exposedVersion")

  implementation("ch.qos.logback:logback-classic:$logbackVersion")
  implementation("io.github.oshai:kotlin-logging-jvm:$loggingVersion")

  testImplementation("io.ktor:ktor-client-mock:$ktorVersion")
  testImplementation("io.ktor:ktor-server-tests-jvm:$ktorVersion")
  testImplementation("org.jetbrains.kotlin:kotlin-test-junit:$kotlinVersion")
}

java {
  withSourcesJar()
}

publishing {
  publications {
    create<MavenPublication>("maven") {
      groupId = "com.vapi4k"
      artifactId = "vapi4k-core"
      version = vstr
      from(components["java"])
    }
  }
}

kotlin {
  jvmToolchain(11)

  sourceSets.all {
    languageSettings.optIn("kotlinx.serialization.ExperimentalSerializationApi")
  }
}

tasks {
  register<Jar>("uberJar") {
    archiveClassifier.set("uber")
    from(sourceSets.main.get().output)
    dependsOn(configurations.runtimeClasspath)
    from({
      configurations.runtimeClasspath.get().filter { it.name.endsWith("jar") }.map { zipTree(it) }
    })
    manifest {
      attributes["Main-Class"] = "com.vapi4k.ApplicationKt"
    }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
  }

  withType<DependencyUpdatesTask> {
    rejectVersionIf {
      listOf("BETA", "-RC").any { candidate.version.uppercase().contains(it) }
    }
  }
}

kotlinter {
  failBuildWhenCannotAutoFormat = false
  ignoreFailures = true
  reporters = arrayOf("checkstyle", "plain")
}

//tasks.dokkaHtml {
//    outputDirectory.set(layout.buildDirectory.dir("documentation/html"))
//}

tasks.withType<DokkaTask>().configureEach {
  dokkaSourceSets.configureEach {
    documentedVisibilities.set(
      setOf(
        Visibility.PUBLIC,
        // Visibility.PROTECTED,
      )
    )

    perPackageOption {
      matchingRegex.set(".*internal.*")
      suppress.set(true)
    }
  }
}

tasks.withType<DokkaTask>().configureEach {
//      "customAssets": ["${file("assets/my-image.png")}"],
//      "customStyleSheets": ["${file("assets/my-styles.css")}"],
//      "separateInheritedMembers": false,
//      "templatesDir": "${file("dokka/templates")}",
//      "mergeImplicitExpectActualDeclarations": false
  val dokkaBaseConfiguration = """
    {
      "footerMessage": "Vapi4k"
    }
    """
  pluginsMapConfiguration.set(
    mapOf(
      // fully qualified plugin name to json configuration
      "org.jetbrains.dokka.base.DokkaBase" to dokkaBaseConfiguration
    )
  )
}

tasks.dokkaHtml.configure {
//    outputDirectory.set(buildDir.resolve("dokka"))

  dokkaSourceSets {
    named("main") {
      //displayName.set("Vapi4k")
      noStdlibLink.set(true)
      noJdkLink.set(true)

      // Exclude everything first
      perPackageOption {
        matchingRegex.set("com.vapi4k.*") // will match kotlin and all sub-packages of it
        suppress.set(true)
      }

      // Include specific packages
      perPackageOption {
        matchingRegex.set("com.vapi4k.api.*") // will match kotlin and all sub-packages of it
        includeNonPublic.set(false)
        reportUndocumented.set(false)
        skipDeprecated.set(false)
        suppress.set(false)
      }
    }
  }
}


//tasks.findByName("lintKotlinCommonMain")?.apply {
//    dependsOn("kspCommonMainKotlinMetadata")
//}


//detekt {
//    buildUponDefaultConfig = true // preconfigure defaults
//    allRules = false // activate all available (even unstable) rules.
//    config.setFrom("$projectDir/config/detekt/detekt.yml") // custom config defining rules to run
//    baseline = file("$projectDir/config/baseline.xml") // a way of suppressing issues before introducing detekt
//}
//
//tasks.withType<Detekt>().configureEach {
//    reports {
//        html.required.set(true) // observe findings in your browser with structure and code snippets
//        xml.required.set(true) // checkstyle like format mainly for integrations like Jenkins
//        // similar to the console output, contains issue signature to manually edit baseline files
//        txt.required.set(true)
//        // standardized SARIF format to support integrations with GitHub Code Scanning
//        sarif.required.set(true)
//        md.required.set(true) // simple Markdown format
//    }
//}
